<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css">

<style>

  body {
    padding: 2em;
  }
  div {
    margin: 1em;
  }
  input {
    display: block;
  }
</style>

<h1>Slice & Export</h1>

<div style="display:flex; flex-direction: row; justify-content: center; align-items: center">
  <label for="username">Size of file</label>
  <input class="input__field" type="text" placeholder="Bytes" id="bytes">

  <!-- <label for="name">Name</label>
  <input class="input__field" type="text" placeholder="Display Name" id="name"> -->
</div>

<div style="text-align: center;">

  <button class="button button--primary" id="submit-post" style="display: inline-block; margin-right: 80px;">Calc</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>

<script>
  
  document.getElementById('submit-post').onclick = () => {
    const message = {}
    parent.postMessage({pluginMessage: message}, '*')
  }

  window.onmessage = async (event) => {
    const arrayData = event.data.pluginMessage;
    arrayBlob = []
    if (arrayData.length) {
      for (data of arrayData) {
          arrayBlob.push([data[0], createBlob(data[1])])
      }
    }

    // handleBlobs(arrayBlob)

    const compressionPromises = arrayBlob.map(([name, blob]) =>
      compressBlob(blob).then((compressedBlob) => [name, compressedBlob])
    );

    Promise.all(compressionPromises)
      .then((compressedBlobs) => {
        // Use the compressed blobs here
        handleBlobs(compressedBlobs);
      })
      .catch((error) => {
        // Handle any errors that occur during the compression process
        console.error('Error compressing blobs:', error);
      });

  }

  function compressBlob(blob) {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext("2d");

      const img = new Image();
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;

        ctx.drawImage(img, 0, 0);
        canvas.toBlob((compressedBlob) => {
          // Clean up the object URL after the blob is created
          URL.revokeObjectURL(img.src);
          resolve(compressedBlob);
        }, blob.type, 0.50);
      };
      img.onerror = (error) => {
        // Clean up the object URL in case of an error
        URL.revokeObjectURL(img.src);
        reject(error);
      };
      img.src = URL.createObjectURL(blob);
    });
  }

  function typedArrayToBuffer(array) {
   return array.buffer.slice(array.byteOffset, array.byteLength + array.byteOffset)
  }

  function createBlob(data) {
    const cleanBytes = typedArrayToBuffer(data)
    const blob = new Blob([ cleanBytes ], { type: 'image/jpeg' });
    console.log(blob.size)
    document.getElementById('bytes').value = cleanBytes
    updateComponent(cleanBytes)
    return blob
  }

  async function updateComponent(data) {
    console.log(data.length)
    const bytesText = document.getElementById('bytes');
    bytesText.value = data.length;
  }

  function handleBlobs(inputBlobs) {
    console.log(inputBlobs)
    let zip = new JSZip();

    for (let blob of inputBlobs) {
      zip.file(`${blob[0]}.jpeg`, blob[1], {base64: true})
    }

    zip.generateAsync({ type: 'blob' })
      .then(function(content) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.innerText = 'Download All Images';
        link.download = 'documents.zip'; // Specify the desired filename for the zip file
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link)
        // Clean up the object URL
        URL.revokeObjectURL(link.href);
      });
  }

</script>